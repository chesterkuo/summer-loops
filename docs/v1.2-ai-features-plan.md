# Warmly v1.2 — AI Features + Messaging Bot Integration

## Development Safety Notice

> **v1.1 (build 58) is currently submitted for iOS App Store review.**
>
> All v1.2 work MUST be developed on a separate `feature/v1.2-ai` branch.
> - Do NOT merge to `main` until v1.1 review is approved
> - Do NOT run SQL migrations against production database
> - Do NOT restart production backend (`pm2 restart warmly-backend`)
> - Do NOT rebuild or resubmit VoltBuilder package
> - Local development and testing only (`bun run dev` / `npm run dev`)
>
> **Deploy checklist (after v1.1 approval):**
> 1. Merge `feature/v1.2-ai` → `main`
> 2. Run SQL migrations against production DB
> 3. Deploy frontend: `npm run build`
> 4. Restart backend: `pm2 restart warmly-backend`
> 5. Build VoltBuilder package for v1.2 submission

## Overview

5 features across 2 categories:
- **AI Agents**: Relationship Coach, Meeting Prep & Follow-Up, Smart Reminders
- **Messaging Bots**: LINE Official Account Bot, WhatsApp Business Bot

### Current AI State (v1.1)

| Feature | How AI is Used | Quality |
|---------|---------------|---------|
| Business card scan | Gemini Vision OCR → structured JSON | Good |
| Quick note / Voice memo | NLP text → contact fields | Good |
| Contact summary | 2-3 sentence profile summary | Good |
| Interaction suggestion | Suggests next touchpoint | Moderate |
| Intro message drafting | 3 tones (formal/casual/brief) | Good |
| Search | Optional query parsing (keyword-based) | Weak |

**Known Issues:**
- All AI outputs hardcoded to Traditional Chinese (should respect user locale)
- No caching of AI responses
- No rate limiting on AI endpoints
- Single provider (Gemini) with no fallback

---

## Part A: AI Agent Features

### A1. Smart Relationship Coach

**Problem:** Users don't know when or how to nurture relationships. Current "suggest interaction" is a one-shot API call with no follow-through.

**Solution:** A proactive AI agent that analyzes all relationships + interaction history.

**What it does:**
- Computes a health score (0-100) per contact based on:
  - Days since last interaction (scaled by expected frequency)
  - Interaction trend (declining = lower score)
  - Relationship strength (higher = more weight)
- Groups contacts into priority buckets: urgent (<30) / due (30-50) / maintain (50-75) / healthy (75+)
- AI generates specific suggested actions and outreach messages per contact
- Shows as a card on Dashboard with top 3 urgent items

**User Experience:**
```
Dashboard → "Relationship Coach" card
  → "3 contacts need attention"
  → Lisa Wong — "It's been 21 days. Send a quick check-in about her new role."
  → [Send] button with pre-drafted message
  → Tap to expand full coach view with all priority groups
```

**Backend:**
- New Gemini function: `analyzeRelationshipHealth(contacts, interactions, relationships, locale)`
- New endpoints:
  - `POST /api/ai/relationship-coach/analyze` — Compute + store health scores
  - `GET /api/ai/relationship-coach/dashboard` — Grouped results

**Database:**
```sql
CREATE TABLE relationship_health_scores (
  id TEXT PRIMARY KEY,
  user_id TEXT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  contact_id TEXT NOT NULL REFERENCES contacts(id) ON DELETE CASCADE,
  health_score INTEGER NOT NULL CHECK(health_score BETWEEN 0 AND 100),
  days_since_interaction INTEGER,
  avg_interaction_frequency_days REAL,
  suggested_action TEXT,
  suggested_message TEXT,
  priority TEXT CHECK(priority IN ('urgent','due','maintain','healthy')),
  computed_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(user_id, contact_id)
);
```

---

### A2. Meeting Prep & Follow-Up

**Problem:** Before meeting a contact, users manually review profiles. After meetings, they forget to log interactions or action items.

**Solution:** Two-part AI assistant for meetings.

**Pre-Meeting Brief:**
- One-page AI-generated brief with:
  - Contact summary and current role
  - Relationship context (how you met, strength)
  - Last interaction recap
  - Talking points based on their interests/recent activity
  - Mutual connections

**Post-Meeting Processing:**
- User provides quick text or voice note
- AI extracts: clean notes, action items with dates, interaction type
- Auto-creates: interaction log, follow-up reminders, updated contact notes

**User Experience:**
```
Contact Profile → "Prep Meeting" button → Brief modal
  → Summary: "Lisa is a Staff Frontend Engineer at Meta..."
  → Last Contact: "Coffee meeting 3 weeks ago, discussed React migration"
  → Talking Points: "Ask about Meta's new AI tools team..."
  → Mutual Connections: "Michael Chen (Google) knows Lisa through..."

Contact Profile → "Log Meeting" → Text input
  → Type: "Had coffee, she's moving to the AI team next month.
     Need to send her the ML paper. Follow up in 2 weeks."
  → AI extracts:
     ✓ Interaction: Coffee meeting (today)
     ✓ Note: "Moving to AI team next month"
     ✓ Action: "Send ML paper" (due: tomorrow)
     ✓ Reminder: "Follow up with Lisa" (in 2 weeks)
  → User confirms → all saved automatically
```

**Backend:**
- New Gemini functions:
  - `generateMeetingBrief(contact, career, interactions, relationships, mutualContacts, locale)`
  - `processMeetingFollowUp(contact, noteText, locale)`
- New endpoints:
  - `POST /api/ai/meeting/brief/:contactId` — Generate brief (cached 24h)
  - `POST /api/ai/meeting/follow-up/:contactId` — Process note → create interaction + reminders

**Database:**
```sql
CREATE TABLE meeting_briefs (
  id TEXT PRIMARY KEY,
  user_id TEXT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  contact_id TEXT NOT NULL REFERENCES contacts(id) ON DELETE CASCADE,
  brief_content JSONB NOT NULL,
  expires_at TIMESTAMPTZ NOT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW()
);
```

---

### A3. Smart Reminders

**Problem:** Current reminders are 100% manual. Users must decide when and why to follow up.

**Solution:** AI analyzes interaction patterns and proactively suggests reminders.

**What it does:**
- Calculates average interaction frequency per contact
- Detects overdue contacts (last interaction > 1.5x their average frequency)
- Generates reminder suggestions with reason and confidence score
- User can Accept (creates real notification) or Dismiss

**User Experience:**
```
Notification Panel → "AI Suggestions" section at top
  → "Lisa Wong — Usually chat every 2 weeks, it's been 3 weeks" [Accept] [Dismiss]
  → "David Lee — Haven't connected since conference 2 months ago" [Accept] [Dismiss]

Accept → Creates notification with suggested date and note
```

**Backend:**
- New Gemini function: `analyzeInteractionPatterns(contacts, interactions, locale)`
- New endpoints:
  - `POST /api/ai/smart-reminders/analyze` — Run analysis, create suggestions
  - `GET /api/ai/smart-reminders/suggestions` — List pending suggestions
  - `POST /api/ai/smart-reminders/accept/:id` — Convert to real notification
  - `POST /api/ai/smart-reminders/dismiss/:id` — Mark dismissed

**Database:**
```sql
CREATE TABLE smart_reminder_suggestions (
  id TEXT PRIMARY KEY,
  user_id TEXT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  contact_id TEXT NOT NULL REFERENCES contacts(id) ON DELETE CASCADE,
  suggestion_text TEXT NOT NULL,
  reason TEXT NOT NULL,
  suggested_date TIMESTAMPTZ NOT NULL,
  confidence REAL CHECK(confidence BETWEEN 0 AND 1),
  status TEXT DEFAULT 'pending' CHECK(status IN ('pending','accepted','dismissed')),
  created_at TIMESTAMPTZ DEFAULT NOW()
);
```

---

## Part B: LINE & WhatsApp Messaging Bot Integration

### Problem

Users meet people and exchange LINE/WhatsApp contacts constantly, but manually entering them into Warmly is friction. There's no way to quickly pipe contacts from messaging apps into the CRM.

### Solution

Official bots on LINE and WhatsApp that accept business card photos, text descriptions, or forwarded contacts and automatically add them to the user's Warmly account.

### User Linking Flow

```
1. User opens Profile → Messaging Integrations → "Connect LINE"
2. App generates 6-digit code (valid 10 minutes)
3. Modal shows: code in large text + QR code to the bot account
4. User opens LINE → adds Warmly bot → sends the 6-digit code
5. Bot validates → links LINE user ID to Warmly account
6. Bot replies: "Connected to Warmly! Send me business cards or contact descriptions."
7. Modal auto-closes (polls every 3s)
```

Same flow for WhatsApp.

### Message Processing

| Message Type | Processing | Result |
|-------------|-----------|--------|
| Text ("Met Sarah Chen at Google, she's a PM") | `parseNaturalLanguage()` | Contact created |
| Photo (business card image) | `scanBusinessCard()` | Contact created with OCR data |
| vCard (WhatsApp only) | Parse vCard fields | Contact created with structured data |
| 6-digit code (unlinked user) | Validate + link account | Account connected |
| Anything else (unlinked user) | — | Reply with linking instructions |

Bot replies with confirmation: "Added: Sarah Chen (Product Manager at Google)"

### Backend Architecture

**New file: `backend/src/routes/messaging.ts`**

| Endpoint | Auth | Purpose |
|----------|------|---------|
| `POST /api/messaging/generate-token` | Yes | Generate 6-digit linking code |
| `GET /api/messaging/accounts` | Yes | List connected accounts |
| `DELETE /api/messaging/accounts/:id` | Yes | Disconnect account |
| `POST /api/messaging/webhooks/line` | No (signature verified) | LINE webhook |
| `GET /api/messaging/webhooks/whatsapp` | No | WhatsApp verification challenge |
| `POST /api/messaging/webhooks/whatsapp` | No (signature verified) | WhatsApp webhook |

**New file: `backend/src/services/messagingBots.ts`**
- LINE event handler + WhatsApp entry handler
- Shared message processors (text, image, vCard)
- Platform-specific reply functions

**Webhook Security:**
- LINE: Verify `X-Line-Signature` header with HMAC-SHA256
- WhatsApp: Verify `X-Hub-Signature-256` header with HMAC-SHA256

### Database

```sql
CREATE TABLE messaging_accounts (
  id TEXT PRIMARY KEY,
  user_id TEXT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  platform TEXT NOT NULL CHECK(platform IN ('line', 'whatsapp')),
  platform_user_id TEXT NOT NULL,
  display_name TEXT,
  linked_at TIMESTAMPTZ DEFAULT NOW(),
  last_message_at TIMESTAMPTZ,
  is_active BOOLEAN DEFAULT TRUE,
  UNIQUE(platform, platform_user_id)
);

CREATE TABLE linking_tokens (
  id TEXT PRIMARY KEY,
  user_id TEXT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  token TEXT NOT NULL UNIQUE,
  platform TEXT NOT NULL CHECK(platform IN ('line', 'whatsapp')),
  expires_at TIMESTAMPTZ NOT NULL,
  used_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ DEFAULT NOW()
);
```

### Frontend

**Profile.tsx** — New "Messaging Integrations" section with:
- LINE card: connected status or "Connect" button
- WhatsApp card: connected status or "Connect" button

**LinkingTokenModal** — Shows:
- Large 6-digit code
- QR code to bot account
- 10-minute countdown timer
- Instructions text
- Auto-closes on successful link

### Environment Variables

```
# LINE Bot
LINE_CHANNEL_SECRET=
LINE_CHANNEL_ACCESS_TOKEN=

# WhatsApp Cloud API
WHATSAPP_ACCESS_TOKEN=
WHATSAPP_PHONE_NUMBER_ID=
WHATSAPP_VERIFY_TOKEN=
WHATSAPP_APP_SECRET=
```

### Platform Setup Required

- **LINE:** Create Official Account at developers.line.biz → Enable Messaging API → Set webhook URL
- **WhatsApp:** Create Meta App at developers.facebook.com → Add WhatsApp Business product → Configure webhook

---

## Cross-Cutting: Multi-Language AI Fix

All Gemini prompts currently hardcode output to Traditional Chinese. Fix by adding a `getLocaleInstruction(locale)` helper that maps user locale to language instruction:

| Locale | Instruction |
|--------|-------------|
| en | "Respond in English" |
| zh-TW | "Respond in Traditional Chinese (繁體中文)" |
| zh-CN | "Respond in Simplified Chinese (简体中文)" |
| ja | "Respond in Japanese (日本語)" |
| ko | "Respond in Korean (한국어)" |
| vi | "Respond in Vietnamese (Tiếng Việt)" |
| th | "Respond in Thai (ไทย)" |
| es | "Respond in Spanish (Español)" |
| fr | "Respond in French (Français)" |

Pass user's locale from frontend via request header or body to all AI endpoints.

---

## Files to Create/Modify

| File | Change |
|------|--------|
| `backend/migrations/003_ai_features.sql` | **New** — 3 tables for AI features |
| `backend/migrations/004_messaging_bots.sql` | **New** — 2 tables for messaging |
| `backend/src/services/gemini.ts` | Add locale helper + 5 new AI functions |
| `backend/src/routes/ai.ts` | Add 8 new endpoints |
| `backend/src/routes/messaging.ts` | **New** — Webhook handlers + linking |
| `backend/src/services/messagingBots.ts` | **New** — Bot message processing |
| `backend/src/index.ts` | Register messaging routes |
| `backend/.env` | Add LINE + WhatsApp credentials |
| `frontend/src/services/api.ts` | Add aiApi + messagingApi methods |
| `frontend/src/screens/Dashboard.tsx` | Add Relationship Coach card |
| `frontend/src/screens/Profile.tsx` | Add Meeting Prep + Messaging Integrations |
| `frontend/src/components/NotificationPanel.tsx` | Add Smart Reminder suggestions |
| `frontend/src/components/LinkingTokenModal.tsx` | **New** — Token display + QR |
| `frontend/src/i18n/locales/*.json` (x9) | Add ~40 translation keys |

## Implementation Order

### Phase 0: Branch Setup
```bash
cd /home/ubuntu/source/summer-loops
git checkout main
git checkout -b feature/v1.2-ai
```
All work happens on `feature/v1.2-ai`. No production impact.

### Phase 1: Foundation (on branch)
1. Write SQL migration files (do NOT run against production)
2. Multi-language AI fix (`getLocaleInstruction` helper) — benefits all features

### Phase 2: AI Features (on branch)
3. Smart Reminders — smallest scope, integrates with existing notifications
4. Relationship Coach — highest user value, builds on reminders infrastructure
5. Meeting Prep & Follow-Up — standalone feature on profile screen

### Phase 3: Messaging Bots (on branch)
6. LINE + WhatsApp Bots — requires external platform setup

### Phase 4: Local Testing (on branch)
- Test with local dev servers (`bun run dev` + `npm run dev`)
- Verify `npm run build` passes with no errors
- Test all endpoints against local PostgreSQL

### Phase 5: Deploy (after v1.1 App Store approval)
1. `git checkout main && git merge feature/v1.2-ai`
2. Run SQL migrations against production DB
3. Add LINE/WhatsApp env vars to production `.env`
4. `pm2 restart warmly-backend`
5. `cd frontend && npm run build` (deploy to web)
6. `./scripts/build-voltbuilder.sh` (v1.2 iOS build)
7. Submit v1.2 to App Store

## Verification (Local Testing)

1. `cd backend && bun run dev` — no startup errors
2. `cd frontend && npm run build` — no TypeScript errors
3. Relationship coach: trigger analyze → dashboard shows grouped contacts
4. Meeting brief: generate for a contact → verify talking points
5. Smart reminders: analyze → accept suggestion → notification created
6. LINE bot: use LINE Developers webhook test tool → verify processing
7. WhatsApp bot: use Meta webhook test tool → verify processing
